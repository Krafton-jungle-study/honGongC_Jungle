# 13. 변수의 영역과 데이터 공유

## 13-1. 변수 사용 영역

---

### 시작하기 전에

- 사용 범위와 메모리 존재 기간에 따라 변수의 종류는 다양함.

```c
auto 자료형 변수명;
```

### 지역 변수

- 지역 변수(local variable) : 범위가 함수 내, 즉 일정 지역에서만 사용하는 변수임.
    - 본래 auto라는 예약어와 함꼐 함수 안에 지역 변수를 선언해야하는 데 이 auto는 생략할 수 있음.
- 지역 변수의 특징
    - 지역 변수는 사용 범위가 블록 내부로 제한되므로 다른 함수에서는 사용할 수 없음.
        - 다른 함수에 동일한 이름의 변수를 선언해도 서로 충돌하지 않음.
        - 두 함수에서 같은 이름의 지역 변수를 사용한 경우
            
            ```c
            #include <stdio.h>
            
            void assign(void);	// 함수 선언
            
            int main(void)
            {
            	auto int a = 0;	**// 지역 변수 선언과 초기화, auto는 생략 가능함.**
            
            	assign();		// 함수 호출
            	printf("main 함수 a : %d\n", a);
            
            	return 0;
            }
            
            void assign(void)
            {
            	int a;	**// main 함수에 있는 변수와 이름만 같은 지역 변수, auto는 생략함.**
            
            	a = 10;	// assign 함수 안에 선언된 a에 대입
            	printf("assing 함수 a : %d\n", a);	// assgin 함수에 선언된 a 값 출력
            }
            ```
            
            ![Untitled](13%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%209d3f4b5fb6fb4151aadb4fa186509aaf/Untitled.png)
            
            - 7행의 변수 a는 사용 범위가 main 함수의 블록으로 제한되고 반대로 17행의 변수 a도 assign 함수 블록으로 제한되기 때문에 서로 영향을 받지 않음.
        - 지역 변수는 이름이 같아도 선언됨 함수가 다르면 각각 독립된 저장 공간을 가짐.
            - 즉, main과 assign의 변수 a는 이름만 같을 뿐 메모리에서 별도의 저장 공간을 가짐.
- 지역 변수 사용의 장점 : 지역 변수의 사용 범위를 함수 단위로 제한하고 독립된 저장 공간을 확보하면 2 가지의 장점이 있음.
    - 메모리를 효율적으로 사용함.
        - 운영체제는 지역 변수가 선언된 함수가 반환되면 할당된 저장 공간을 자동으로 회수해 재활용함.
    - 디버깅에 유리함.
        - 문제가 발생한 함수 안에서만 그 원인을 찾으면 되기 때문에 문제가 있을 때 수정하기 쉬움.

### 블록 안에서 사용하는 지역 변수

- 보통 지역 변수는 함수 안에서 선언된 후 함수 끝까지 사용되지만, 선언 위치에 따라 사용 범위가 달라질 수 있음.
- 특정 블록 안에 변수를 선언하면 사용 범위가 블록 내부로 제한됨.
    - 변수가 할당된 메모리의 저장 공간도 블록이 끝나면 자동으로 회수되어 사용 범위가 제한됨.
    - 블록 안에 지역 변수를 사용해 두 변수를 교환하는 프로그램
        
        ```c
        #include <stdio.h>
        
        int main(void)
        {
        	int a = 10, b = 20;
        
        	printf("교환 전 a와 b의 값 : %d, %d\n", a, b);
        	{				// 블록 시작
        		int temp;	// temp 변수 선언
        
        		temp = a;
        		a = b;		// a와 b는 5행에 선언된 변수
        		b = temp;
        	}				// 블록 끝
        	printf("교환 후 a와 b의 값 : %d, %d\n", a, b);
        
        	return 0;
        }
        ```
        
        ![Untitled](13%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%209d3f4b5fb6fb4151aadb4fa186509aaf/Untitled%201.png)
        

### 전역 변수

- 전역 변수 : 함수 밖에서 선언한 변수로 특정 함수의 블록에 포함되지 않으므로 사용 범위가 함수나 블록으로 제한되지 않음. (전역 변수는 프로그램 어디에서나 사용할 수 있음.)
    - 전역 변수의 사용
        
        ```c
        #include <stdio.h>
        
        void assign10(void);
        void assign20(void);
        
        int a;	// 전역 변수 선언 (함수 밖에서 변수를 선언)
        
        int main(void) 
        {
        	printf("함수 호출 전 a 값 : %d\n", a);	// 전역 변수 a 출력 (지역 변수는 자동 초기화가 되지 않으나 전역 변수는 0으로 자동 초기화됨.)
        
        	assign10();
        	assign20();
        
        	printf("함수 호출 후 a 값 : %d\n", a);	// 전역 변수 a 출력
        
        	return 0;
        }
        
        void assign10(void)
        {
        	a = 10;	// 전역 변수 a에 10 대입
        }
        
        void assign20(void)
        {
        	int a;	// 전역 변수와 같은 이름의 지역 변수 선언
        
        	a = 20;	// 지역 변수 a에 20 대입
        }
        ```
        
        ![Untitled](13%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%209d3f4b5fb6fb4151aadb4fa186509aaf/Untitled%202.png)
        
        - 6행 : int a;
            - 전역 변수를 선언한 부분이며 전역 변수는 프로그램 시작과 동시에 할당되어 종료시까지 존재함.
            - 전역 변수 a의 사용 범위 : main 함수 영역, assign10 함수 영역 그리고 assign20 함수 영역 (단, assign20에는 지역 변수가 선언되어 있어 영향을 미치지는 못함.)
        - 10행 : printf("함수 호출 전 a 값 : %d\n", a);
            - 지역 변수는 자동 초기화되지 않지만 전역 변수는 0으로 자동 초기화됨.
        - 전역 변수와 같은 이름의 지역 변수
            - 전역 변수와 지역 변수의 이름이 같으면 지역 변수 먼저 사용함.
            - assign10 함수의 경우에는 함수 내부적으로 따로 지역 변수가 정해진 게 없기 때문에 전역 변수에 영향을 미치지만, 반대로 assing20 함수의 경우에는 함수 내부에 지역 변수가 있기 때문에 지역 변수에 영향을 미침.
- 전역 변수의 문제점
    - 전역 변수는 모든 함수에서 자유롭게 접근할 수 있으므로 같은 변수를 여러 함수에 공유할 수 있다는 장점이 있지만 몇 가지 문제점이 있음.
        - 전역 변수의 이름을 바꾸면 그 변수를 사용하는 모든 함수를 찾아 수정해야 함.
        - 전역 변수의 값이 잘못된 경우 접근 가능한 모든 함수를 의심해야 함. (디버깅의 난이도가 높아짐.)
        - 코드 블록 내에 같은 이름의 지역 변수를 선언하면 거기서는 전역 변수를 사용할 수 없음.
    - 결론 : 사용 범위가 명확하고 통제 가능한 지역 변수를 우선적으로 사용하고, 전역 변수를 제한적으로 사용하거나 사용하지 않는 게 좋음.

### 정적 지역 변수

- 지역 변수를 선언할 때 static 예약어를 사용하면 정적 지역 변수(static variable)이 됨.
- 일반 지역 변수와의 차이점 : 저장 공간이 메모리에 존재하는 기간이 다름.
    - 정적 지역 변수는 선언된 함수가 반환되더라도 그 저장 공간을 계속 유지함. 따라서 하나의 함수가 여러 번 호출되는 경우 같은 변수를 공유하는 것이 가능함.
    - 정적 지역 변수의 저장 공간은 프로그램이 실행되는 동안 계속 유지됨.
    - auto 지역 변수와 statice 지역 변수의 비교
        
        ```c
        #include <stdio.h>
        
        void auto_func(void);	// auto_func 함수 선언
        void static_func(void);	// static_func 함수 선언
        
        int main(void)
        {
        	int i;
        
        	printf("일반 지역 변수(auto)를 사용한 함수...\n");
        	for (i = 0; i < 3; i++)
        	{
        		auto_func();
        	}
        
        	printf("정적 지역 변수(static)를 사용한 함수...\n");
        	for (i = 0; i < 3; i++)
        	{
        		static_func();
        	}
        
        	return 0;
        }
        
        void auto_func(void)
        {
        	auto int a = 0;	// 지역 변수 선언과 초기화
        
        	a++;	// a 값 1 증가
        	printf("%d\n", a);	// a 출력
        }
        
        void static_func(void)
        {
        	static int a;	// 정적 지역 변수 선언 (저장공간이 프로그램이 실행되는 동안 계속 유지됨.)
        
        	a++;	// a 값 1 증가
        	printf("%d\n", a);	// a 출력
        }
        ```
        
        ![Untitled](13%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%209d3f4b5fb6fb4151aadb4fa186509aaf/Untitled%203.png)
        
        - 25행 : auto_func 함수
            - 지역 변수는 함수가 호출될 때 메모리에 할당되고 반환될 때 메모리에서 제거되므로 변수 a는 auto_func 함수가 호출될 때마다 메모리에 새롭게 할당되고 그때마다 0으로 초기화됨.
        - 35행 : static 예약어
            - 지역변수에 static을 붙이면 저장 공간이 프로그램이 종료될때까지 할당되며 함수 호출과는 상관이 없어짐.
                - 그렇기 때문에 함수를 반환하더라도 저장 공간이 계속 유지되어 값들이 1 → 2 → 3으로 유지됨.

### 레지스터 변수

- 레지스터 변수(register variable)
    - 레지스터 변수는 CPU 안에 있는 저장 공간인 레지스터를 활용함.
    - 레지스터는 CPU 안에 있어 데이터 처리 속도가 가장 빠르기 때문에 반복문에 쓰는 변수와 같이 사용 횟수가 많은 경우 레지스터에 할당하면 실행 시간을 줄일 수 있음.
- 레지스터 변수를 반복문에 사용한 예
    
    ```c
    #include <stdio.h>
    
    int main(void)
    {
    	register int i;	// 레지스터 변수
    	auto int sum = 0;	// auto 지역 변수
    
    	for (i = 1; i <= 10000; i++)	// 반복 과정에서 변수 i를 계속 사용함.
    	{
    		sum += i;	// i 값을 반복해서 누적
    	}
    
    	printf("%d\n", sum);
    
    	return 0;
    }
    ```
    
    ![Untitled](13%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%209d3f4b5fb6fb4151aadb4fa186509aaf/Untitled%204.png)
    
    - 위 예제에서 i는 8행과 10행에서 계속 사용되고 있기 때문에 이와 같이 자주 사용하는 변수를 레지스터 변수로 선언하면  변수의 데이터 처리 속도가 램 메모리에 있을 때보다 빨라 프로그램 실행 시간을 줄일 수 있음.
- 레지스터 변수 사용 시 주의점
    - 전역 변수는 레지스터 변수로 선언할 수 없음.
        - 레지스터 변수는 CPU의 자원을 잠시 빌리는 것이기 때문에 프로그램을 실행하는 동안 계속 저장 공간을 확보해야 하는 전역 변수는 레지스터에 할당할 수 없음.
    - 레지스터 변수는 주소를 구할 수 없음.
        - 레지스터 변수는 저장 공간이 메모리에 있는 것이 아니기 때문에 주소 연산자를 써서 주소를 구할 수 없음.
    - 레지스터의 사용 여부는 컴파일러가 결정함.
        - 레지스터 변수로 선언했다고 해서 레지스터에 변수가 100% 생성되는 것은 아님. (이유 : 당장 연산할 필요가 없는 데이터를 레지스터에 보관하면 레지스터의 활용성이 떨어짐.)
        - 우리가 사용하는 컴파일러는 사용자가 레지스터 변수를 선언하더라도 레지스터와 메모리 중에 어디에 할당하는 것이 더 이득인지 판단해 적당한 저장 공간을 선택함.

### 마무리

- 4가지 키워드로 끝내는 핵심 포인트
    - **지역 변수**의 사용 범위는 블록으로 제한됨.
    - 지역 변수와 **전역 변수**의 사용 범위가 겹치면 지역 변수를 먼저 사용함.
    - 지역 변수에 static을 사용해서 **정적 지역 변수**로 만들면 프로그램의 시작부터 종료까지 저장 공간이 유지됨.
    - **레지스터 변수**는 컴파일러가 레지스터에 생성할지 말지를 결정함.
- 확인 문제
    - 프로그램에서 사용하는 변수는 사용 범위에 따라 간단히 지역 변수와 전역 변수로 구분함.
    - 그러나 같은 지역 변수라도 저장 공간의 유지 기간이 다른 정적 지역 변수(static)이 있고 저장 공간이 메모리가 아닌 레지스터인 것도 있음.
    - 이러한 특성을 이해하고 적절히 사용하여 안정적이고 효율적인 프로그램을 만드는 것이 개발자의 역할임.
    
    ```c
    #include <stdio.h>
    
    void func(void);
    
    int a = 10;	// 전역 변수 선언 및 초기화
    
    int main(void)
    {
    	a = 20;
    	func();	// 함수 호출
    	printf("%d", a);
    	return 0;
    }
    
    void func(void)
    {
    	a = 30;
    }
    ```
    
    ![Untitled](13%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%209d3f4b5fb6fb4151aadb4fa186509aaf/Untitled%205.png)
    
    ```c
    #include <stdio.h>
    
    int func(void);
    
    int main(void)
    {
    	int i, sum = 0;
    
    	for (i = 0; i < 10; i++)
    	{
    		sum += func();
    	}
    
    	printf("$%d", sum);
    	return 0;
    }
    
    int func(void)
    {
    	static int a = 0;
    	a++;
    	return a;
    }
    ```
    
    - 정적 지역 변수(static)은 함수가 반환되더라도 그 저장 공간을 계속 유지함.

## 13-2. 함수의 데이터 공유 방법

---

### 시작하기 전에

- 프로그램은 데이터와 명령으로 이뤄지며 컴퓨터가 주로 하는 일은 데이터를 명령으로 처리하는 일이고 이때 특정 기능의 명령을 묶어서 함수로 만듦.

### 값을 복사해서 전달하는 방법

- 값을 복사해서 전달하는 방법
    - 함수를 호출할 때 필요한 데이터를 전달하는 가장 일반적인 방법
    - 호출된 함수가 반환된 이후에도 호출한 함수에 있는 변수의 값은 변하지 않음.
    - 10을 더하기 위해 값을 인수로 주는 경우
        
        ```c
        #include <stdio.h>
        
        void add_ten(int a);	// 함수 선언
        
        int main(void)
        {
        	int a = 10;
        
        	add_ten(a);	// a 값을 복사해 전달
        	printf("a : %d\n", a);
        
        	return 0;
        }
        
        void add_ten(int a)	// 7행의 a와 다른 독립적인 저장 공간 할당
        {
        	a = a + 10;	// 15행의 매개변수 a에 10을 더한다.
        }
        ```
        
        ![Untitled](13%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%209d3f4b5fb6fb4151aadb4fa186509aaf/Untitled%206.png)
        
        ```c
        #include <stdio.h>
        
        int add_ten(int a);	// 반환값이 있는 함수로 선언
        
        int main(void)
        {
        	int a = 10;
        
        	a = add_ten(a);	// 증가한 값을 반환해 main 함수의 변수 a에 대입
        	printf("a : %d\n", a);
        
        	return 0;
        }
        
        int add_ten(int a)	// 반환값이 있는 함수로 정의
        {
        	a = a + 10;	// 15행의 매개변수 a에 10을 더한다.
        
        	return a;
        }
        ```
        
        ![Untitled](13%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%209d3f4b5fb6fb4151aadb4fa186509aaf/Untitled%207.png)
        
        - 차이점
            - 17행에서 매개변수 a를 증가시켜도 main 함수에 있는 a는 변함이 없음. (이유 : 새로 저장된 값을 main 함수로 전달하지 않았기 때문에)
            - 만약 main 함수의 변수 a가 증가하기를 원한다면 두 번째 코드처럼 main 함수에 다시 a를 대입하는 식으로 수정하면 됨.
                
                ```c
                a = add_ten(a) // 증가한 값을 반환해 main 함수의 변수 a에 대입
                ```
                

### 주소를 전달하는 방법

- 포인터 연산을 활용하여 함수를 호출할 때 처리할 변수의 주소를 전달하는 방법도 있음.
- 이것은 호출된 함수에서 호출한 함수에 있는 변수의 값을 바꿀 수 있다는 장점이 있음. (주소를 전달하면 호출한 함수의 변숫값을 바꿀 수 있음.)
- 포인터를 써서 변수의 값에 10을 더하는 경우
    
    ```c
    #include <stdio.h>
    
    void add_ten(int* pa);	// 매개변수로 포인터 pa 선언
    
    int main(void)
    {
    	int a = 10;
    
    	add_ten(&a);	// a의 주소를 인수로 준다.
    	printf("a : %d\n", a);	// 증가된 a 값 출력
    
    	return 0;
    }
    
    void add_ten(int* pa)	// 포인터 pa가 a의 주소를 받는다.
    {
    	*pa = *pa + 10;	// 포인터 pa가 가리키는 변수의 값 10 증가
    }
    ```
    
    ![Untitled](13%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%209d3f4b5fb6fb4151aadb4fa186509aaf/Untitled%208.png)
    
    - 9행 : 변수 a의 주소가 함수에 전달됨.
    - 15행 : 포인터를 매개변수로 받음.
    - 17행 : 매개변수 pa에 간접 참조 연산자를 사용하면 main 함수에 있는 a를 사용할 수 있고 수정도 가능함.
- 값을 복사해서 전달하는 방식 vs 주소를 전달하는 방식
    - 값을 복사해서 전달하는 방식
        - 원본 데이터를 보존할 수 있으므로 안정성이 보장됨.
        - 하지만, 원본 데이터 수정이 목적일 경우에는 제한사항이 있음.
    - 주소를 전달하는 방식
        - 원본 데이터를 바꿀 때 유용함.
        - 사용법이 복잡하며 절대 바꾸면 안 되는 데이터를 다룰 때 사용하면 준제가 생길 수 있음.

### 주소를 반환하는 함수

- 반환값이 있는 함수는 호출한 함수로 값을 복사해서 반환함.
- 함수 안에서 사용한 지역 변수는 함수가 반환되면 저장 공간이 사라지므로 그 값을 복사해 반환해야 호출한 함수에서 사용할 수 있음.
- 만약 함수가 반환된 후에도 변수의 저장 공간이 계속 유지된다면 주소를 반환해 호출하는 함수에서 쓸 수 도 있음.
- 즉, 정적 지역 변수(static)과 전역 변수는 주소를 반환할 수 있음.
- 주소를 반환해서 두 정수의 합 계산
    
    ```c
    #include <stdio.h>
    
    int* sum(int a, int b);	// int형 변수의 주소를 반환하는 함수 선언
    
    int main(void)
    {
    	int* resp;	// 반환값을 저장할 포인터 resp(result pointer)
    
    	resp = sum(10, 20);	// 반환된 주소는 resp에 저장
    	printf("두 정수의 합 : %d\n", *resp);	// resp가 가리키는 변숫값 출력
    
    	return 0;
    }
    
    int* sum(int a, int b)	// int형 변수의 주소를 반환하는 함수
    {
    	static int res;	// 정적 지역 변수
    
    	res = a + b;	// 두 정수의 합을 res(result)에 저장
    
    	return &res;	// 정적 지역 변수의 주소 반환
    }
    ```
    
    ![Untitled](13%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%80%E1%85%AA%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%B2%209d3f4b5fb6fb4151aadb4fa186509aaf/Untitled%209.png)
    
    - sum 함수는 매개변수로 받은 두 정수를 더한 후에 직접 반환하지 않고 res 변수에 저장하고 res의 주소를 반환함.
    - 이 경우 값을 포인터에 저장하고 간접 참조 연산을 수행해 언제든지 두 정수의 합을 사용할 수 있음.
- 주소를 반환하는 함수를 만들 때의 두 가지 주의점
    - 반환값의 자료형은 반환값을 저장할 포인터의 자료형과 같아야 함.
        - 즉, sum 함수는 int 형 변수인 res의 주소를 반환하므로 그 값을 저장할 포인터는 int *형으로 선언해야 함.
    - 지역 변수의 주소를 반환해서는 안됨.
        - static을 사용한 정적 지역 변수를 사용해야 함수가 반환된 후에도 저장 공간이 계속 유지되므로 호출한 함수에서 포인터 연산을 통해 언제든지 정적 지역 변수의 사용이 가능함.
        - 일반 지역 변수는 함수가 반환되면 저장 공간이 회수되어 재활용이 불가함.

### 마무리

- 3가지 키워드로 끝내는 핵심 포인트
    - **값을 복사해서** 인수로 **전달**하면 호출하는 함수의 값은 바뀌지 않음.
    - 호출하는 함수의 값을 바꾸려면 **주소**를 인수로 **전달**해야 함.
    - 정적 지역 변수나 전역 변수와 같이 함수가 반환된 후에도 저장 공간이 유지되는 경우에만 **주소를 반환**함.
- 확인 문제
    
    ```c
    #include <stdio.h>
    
    int* get_num(void)
    {
    	int n;	// 정수를 입력할 변수
    	scanf("%d", &n);	// n에 정수 입력
    	return &n;	// n의 주소 반환
    }
    ```